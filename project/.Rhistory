models[count,] <- lm(y~poly(x, degree=degree, raw=TRUE), data[(i-window.size+ 1):i,])$coeff
lines(x=data[(i-window.size + 1):i,1], y = predict.lwr(data[(i-window.size+ 1):i,1], models[count,]), col="blue")
}
count
plot(csr3$FT, csr3$FN)
models
models[1,]
window.size=10
step.size=10
degree=1
predicting.degree=NA
data =  traindf
step.size = window.size
if(is.na(predicting.degree)){
predicting.degree=degree
}
#fit local regression models in a sliding window fashion
#initial fit section of paper
dat<- rep(0, (length(data$x) - window.size + 1))
models <- data.frame(matrix(vector(), nrow=length(seq(window.size, length(data$x), step.size)), ncol=degree +1) )
count = 0
for(i in seq(window.size, length(data$x), step.size)){
count <- count + 1
models[count,] <- lm(y~poly(x, degree=degree, raw=TRUE), data[(i-window.size+ 1):i,])$coeff
lines(x=data[(i-window.size + 1):i,1], y = predict.lwr(data[(i-window.size+ 1):i,1], models[count,]), col="blue")
}
#fit a model to the params of the sliding window models
#prediction section of the paper
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1]) + 2))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
#then we can use params to make the model after the data.
#but before we use teh params lets first do error correction
#error correction section fo the paper
error_params = rep(0, degree+ 1)
ma = rep(0, 2)
epsilon = rep(0, 2)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,length(models[,1]) -1 ), "y" = models[length(models[,1])-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1]), count -1) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
params[d] <- params[d] +  epsilon[d]
#moving average error correction
ma[d] = mean(tail(moving.average(models[,d]), n=ma.size))
params[d] = 0.5*( params[d] + ma[d])
}
window.size=10
step.size=10
degree=1
predicting.degree=NA
data =  traindf
step.size = window.size
ma.size = 3
if(is.na(predicting.degree)){
predicting.degree=degree
}
#fit local regression models in a sliding window fashion
#initial fit section of paper
dat<- rep(0, (length(data$x) - window.size + 1))
models <- data.frame(matrix(vector(), nrow=length(seq(window.size, length(data$x), step.size)), ncol=degree +1) )
count = 0
for(i in seq(window.size, length(data$x), step.size)){
count <- count + 1
models[count,] <- lm(y~poly(x, degree=degree, raw=TRUE), data[(i-window.size+ 1):i,])$coeff
lines(x=data[(i-window.size + 1):i,1], y = predict.lwr(data[(i-window.size+ 1):i,1], models[count,]), col="blue")
}
#fit a model to the params of the sliding window models
#prediction section of the paper
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1]) + 2))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
#then we can use params to make the model after the data.
#but before we use teh params lets first do error correction
#error correction section fo the paper
error_params = rep(0, degree+ 1)
ma = rep(0, 2)
epsilon = rep(0, 2)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,length(models[,1]) -1 ), "y" = models[length(models[,1])-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1]), count -1) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
params[d] <- params[d] +  epsilon[d]
#moving average error correction
ma[d] = mean(tail(moving.average(models[,d]), n=ma.size))
params[d] = 0.5*( params[d] + ma[d])
}
params
predict.lwr(testdf$x, params)
epsilon[d] = models[count,d] - error_params[d]
epsilon
models[count,d]
error_params[d]
d=1
#make data to train
dat <- data.frame("x" = seq(1,length(models[,1]) -1 ), "y" = models[length(models[,1])-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1]), count -1) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
params[d] <- params[d] +  epsilon[d]
#moving average error correction
ma[d] = mean(tail(moving.average(models[,d]), n=ma.size))
params[d] = 0.5*( params[d] + ma[d])
epsilon
models[count,d]
error_params[d]
#make data to test
dat <- data.frame("x" = seq(length(models[,1]), count) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
params[d] <- params[d] +  epsilon[d]
error_params
models
error_params[d]
models[count,d]
dat <- data.frame("x" = seq(1,length(models[,1]) -1 ), "y" = models[length(models[,1])-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1]), count) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
error_params[d]
models[count,d]
#make data to test
dat <- data.frame("x" = seq(count, count + 1) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
error_params[d]
dat <- data.frame("x" = seq(1,count - 1 ), "y" = models[count-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(count, count + 1) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
error_params[d]
tail(predict.lm(mod,  dat), n=1)
#make data to test
dat <- data.frame("x" = seq(count, count ) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
tail(predict.lm(mod,  dat), n=1)
#make data to test
dat <- data.frame("x" = seq(count, count ) )
predict.lm(mod,  dat)
#make data to test
dat <- data.frame("x" = seq(count, count +1 ) )
predict.lm(mod,  dat)
#make data to train
dat <- data.frame("x" = seq(1,count - 1 ), "y" = models[count-1,d])
lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1]) + 2))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
params
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1]) + 2))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
params
models
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1]) + 2))
params[d] <- tail(predict.lm(mod,  dat), n=1)
params
}
params
data.frame("x" = seq(length(models[,1])+1, length(models[,1])+ 1))
models
#fit a model to the params of the sliding window models
#prediction section of the paper
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1])+ 1))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
error_params = rep(0, degree+ 1)
params
error_params = rep(0, degree+ 1)
ma = rep(0, 2)
epsilon = rep(0, 2)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count - 1 ), "y" = models[count-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(count, count +1 ) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
params[d] <- params[d] +  epsilon[d]
#moving average error correction
ma[d] = mean(tail(moving.average(models[,d]), n=ma.size))
params[d] = 0.5*( params[d] + ma[d])
}
params
window.size=10
step.size=10
degree=1
predicting.degree=NA
data =  traindf
step.size = window.size
ma.size = 3
if(is.na(predicting.degree)){
predicting.degree=degree
}
#fit local regression models in a sliding window fashion
#initial fit section of paper
dat<- rep(0, (length(data$x) - window.size + 1))
models <- data.frame(matrix(vector(), nrow=length(seq(window.size, length(data$x), step.size)), ncol=degree +1) )
count = 0
for(i in seq(window.size, length(data$x), step.size)){
count <- count + 1
models[count,] <- lm(y~poly(x, degree=degree, raw=TRUE), data[(i-window.size+ 1):i,])$coeff
lines(x=data[(i-window.size + 1):i,1], y = predict.lwr(data[(i-window.size+ 1):i,1], models[count,]), col="blue")
}
#fit a model to the params of the sliding window models
#prediction section of the paper
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1])+ 1))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
#then we can use params to make the model after the data.
#but before we use teh params lets first do error correction
#error correction section fo the paper
error_params = rep(0, degree + 1)
ma = rep(0, degree + 1)
epsilon = rep(0, degree + 1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count - 1 ), "y" = models[count-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(count, count +1 ) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
params[d] <- params[d] +  epsilon[d]
#moving average error correction
ma[d] = mean(tail(moving.average(models[,d]), n=ma.size))
params[d] = 0.5*( params[d] + ma[d])
}
params
error_params
epsilon
data.frame("x" = seq(count, count +1 ) )
tail(predict.lm(mod,  dat), n=1)
predict.lm(mod,  dat)
models
models[count,d] - error_params[d]
lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
lwr <- function(data, window.size=10, step.size=5, degree=1, predicting.degree=NA, ma.size = 3){
window.size=10
step.size=10
degree=1
predicting.degree=NA
data =  traindf
step.size = window.size
ma.size = 3
if(is.na(predicting.degree)){
predicting.degree=degree
}
#fit local regression models in a sliding window fashion
#initial fit section of paper
dat<- rep(0, (length(data$x) - window.size + 1))
models <- data.frame(matrix(vector(), nrow=length(seq(window.size, length(data$x), step.size)), ncol=degree +1) )
count = 0
for(i in seq(window.size, length(data$x), step.size)){
count <- count + 1
models[count,] <- lm(y~poly(x, degree=degree, raw=TRUE), data[(i-window.size+ 1):i,])$coeff
lines(x=data[(i-window.size + 1):i,1], y = predict.lwr(data[(i-window.size+ 1):i,1], models[count,]), col="blue")
}
#fit a model to the params of the sliding window models
#prediction section of the paper
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1])+ 1))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
#then we can use params to make the model after the data.
#but before we use teh params lets first do error correction
#error correction section fo the paper
error_params = rep(0, degree + 1)
ma = rep(0, degree + 1)
epsilon = rep(0, degree + 1)
params
}
params
window.size=10
step.size=10
degree=1
predicting.degree=NA
data =  traindf
step.size = window.size
ma.size = 3
if(is.na(predicting.degree)){
predicting.degree=degree
}
#fit local regression models in a sliding window fashion
#initial fit section of paper
dat<- rep(0, (length(data$x) - window.size + 1))
models <- data.frame(matrix(vector(), nrow=length(seq(window.size, length(data$x), step.size)), ncol=degree +1) )
count = 0
for(i in seq(window.size, length(data$x), step.size)){
count <- count + 1
models[count,] <- lm(y~poly(x, degree=degree, raw=TRUE), data[(i-window.size+ 1):i,])$coeff
lines(x=data[(i-window.size + 1):i,1], y = predict.lwr(data[(i-window.size+ 1):i,1], models[count,]), col="blue")
}
#fit a model to the params of the sliding window models
#prediction section of the paper
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1])+ 1))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
#then we can use params to make the model after the data.
#but before we use teh params lets first do error correction
#error correction section fo the paper
error_params = rep(0, degree + 1)
ma = rep(0, degree + 1)
epsilon = rep(0, degree + 1)
params
d=1
#make data to train
dat <- data.frame("x" = seq(1,count - 1 ), "y" = models[count-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(count, count +1 ) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
params[d] <- params[d] +  epsilon[d]
#moving average error correction
ma[d] = mean(tail(moving.average(models[,d]), n=ma.size))
params[d] = 0.5*( params[d] + ma[d])
#make data to train
dat <- data.frame("x" = seq(1,count - 1 ), "y" = models[count-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(count, count +1 ) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
error_params
d=2
#make data to train
dat <- data.frame("x" = seq(1,count - 1 ), "y" = models[count-1,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(count, count +1 ) )
error_params[d] <- tail(predict.lm(mod,  dat), n=1)
error_params
#prediction error correction
epsilon[d] = models[count,d] - error_params[d]
epsilon
data.frame("x" = seq(length(models[,1])+1, length(models[,1])+ 1))
data.frame("x" = seq(count, count +1 )
)
predict.lm(mod,  dat)
window.size=10
step.size=10
degree=1
predicting.degree=NA
data =  traindf
step.size = window.size
ma.size = 3
if(is.na(predicting.degree)){
predicting.degree=degree
}
#fit local regression models in a sliding window fashion
#initial fit section of paper
dat<- rep(0, (length(data$x) - window.size + 1))
models <- data.frame(matrix(vector(), nrow=length(seq(window.size, length(data$x), step.size)), ncol=degree +1) )
count = 0
for(i in seq(window.size, length(data$x), step.size)){
count <- count + 1
models[count,] <- lm(y~poly(x, degree=degree, raw=TRUE), data[(i-window.size+ 1):i,])$coeff
lines(x=data[(i-window.size + 1):i,1], y = predict.lwr(data[(i-window.size+ 1):i,1], models[count,]), col="blue")
}
#fit a model to the params of the sliding window models
#prediction section of the paper
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1])+ 1))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
params
window.size=10
step.size=8
degree=1
predicting.degree=NA
data =  traindf
step.size = window.size
ma.size = 3
if(is.na(predicting.degree)){
predicting.degree=degree
}
#fit local regression models in a sliding window fashion
#initial fit section of paper
dat<- rep(0, (length(data$x) - window.size + 1))
models <- data.frame(matrix(vector(), nrow=length(seq(window.size, length(data$x), step.size)), ncol=degree +1) )
count = 0
for(i in seq(window.size, length(data$x), step.size)){
count <- count + 1
models[count,] <- lm(y~poly(x, degree=degree, raw=TRUE), data[(i-window.size+ 1):i,])$coeff
lines(x=data[(i-window.size + 1):i,1], y = predict.lwr(data[(i-window.size+ 1):i,1], models[count,]), col="blue")
}
#fit a model to the params of the sliding window models
#prediction section of the paper
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1])+ 1))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
8
params
window.size=10
step.size=10
degree=1
predicting.degree=NA
data =  traindf
step.size = window.size
ma.size = 3
if(is.na(predicting.degree)){
predicting.degree=degree
}
#fit local regression models in a sliding window fashion
#initial fit section of paper
dat<- rep(0, (length(data$x) - window.size + 1))
models <- data.frame(matrix(vector(), nrow=length(seq(window.size, length(data$x), step.size)), ncol=degree +1) )
count = 0
for(i in seq(window.size, length(data$x), step.size)){
count <- count + 1
models[count,] <- lm(y~poly(x, degree=degree, raw=TRUE), data[(i-window.size+ 1):i,])$coeff
lines(x=data[(i-window.size + 1):i,1], y = predict.lwr(data[(i-window.size+ 1):i,1], models[count,]), col="blue")
}
#fit a model to the params of the sliding window models
#prediction section of the paper
params = rep(0, degree+1)
for(d in seq(degree + 1) ){
#make data to train
dat <- data.frame("x" = seq(1,count), "y" = models[,d])
mod <- lm(y~poly(x, degree=predicting.degree, raw=TRUE), dat)
#make data to test
dat <- data.frame("x" = seq(length(models[,1])+1, length(models[,1])+ 1))
params[d] <- tail(predict.lm(mod,  dat), n=1)
}
params
